// Version 081
#import "Basic";

linkS :: struct ($T : Type)
{
    prev : *linkS(T);
    next : *linkS(T);
    data : T;
}

// This code is expanded into the callsite
link_left_middle_right :: (left : *linkS, middle : *linkS, right : *linkS) #expand
{
    left.next = middle;
    middle.prev = left;
    middle.next = right;
    right.prev = middle;
}

// #modify narrows valid types into a single implementation
// One function is generated by the compiler for link_add
link_add :: (link : *$T, add : *T)
#modify {
    if (T.type != .STRUCT) {
        T = null;
        return;
    }

    struct_info := cast (*Type_Info_Struct) T;
    restrict_type := type_info(linkS(void)).polymorph_source_struct;
    if struct_info.polymorph_source_struct != restrict_type {
        T = null;
    } else {
        T = type_info(void);
    }
}
{
    // Casting feels redundant, type checking is specified by #modify
    any :: linkS(void);
    any_link : *any = link;
    any_add : *any = add;

    link_left_middle_right(any_link, any_add, any_link.next);
}

// This is polymorphic, ($T) is implied by the type linkS
// Code generation occurs for each variant of linkS
link_dump :: (link : *linkS) {
    print("link_dump\n");
    iter := link;
    count := 0;
    while (true) {
        print("% %: %\n", count, iter, <<iter);
        iter = iter.next;
        count += 1;
        if (iter == link) break;
    }
}

main :: ()
{
    make_link :: ($T : Type) -> *linkS(T) #expand {
        value : linkS(T);
        value.prev = *value;
        value.next = *value;
        print("make %: %\n", *value, value);
        return *value;
    }

    print("void test\n");
    first_void := make_link(void);
    second_void := make_link(void);
    link_add(first_void, second_void);
    link_dump(first_void);

    print("\nunit test\n");
    unitS :: struct {}
    first_unit := make_link(unitS);
    second_unit := make_link(unitS);

    link_dump(first_unit);
    link_add(first_unit, second_unit);
    link_dump(first_unit);
}
